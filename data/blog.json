[{"id":12,"title":"Next.js 14.1","content":"Next.js 14.1 includes developer experience improvements including:\n\nImproved Self-Hosting: New documentation and custom cache handler\nTurbopack Improvements: 5,600 tests passing for next dev --turbo\nDX Improvements: Improved error messages, pushState and replaceState support\nParallel & Intercepted Routes: 20 bug fixes based on your feedback\nnext/image Improvements: <picture>, art direction, and dark mode support\nUpgrade today or get started with:\n\nTerminal\n\nnpx create-next-app@latest\nImproved Self-Hosting\nWe've heard your feedback for improved clarity on how to self-host Next.js with a Node.js server, Docker container, or static export. We've overhauled our self-hosting documentation on:\n\nRuntime environment variables\nCustom cache configuration for ISR\nCustom image optimization\nMiddleware\nWith Next.js 14.1, we've also stabilized providing custom cache handlers for Incremental Static Regeneration and the more granular Data Cache for the App Router:\n\nnext.config.js\n\nmodule.exports = {\n  cacheHandler: require.resolve('./cache-handler.js'),\n  cacheMaxMemorySize: 0, // disable default in-memory caching\n};\nUsing this configuration when self-hosting is important when using container orchestration platforms like Kubernetes, where each pod will have a copy of the cache. Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application.\n\nFor instance, you can save the cached values anywhere, like Redis or Memcached. We'd like to thank @neshca for their Redis cache handler adapter and example.\n\nTurbopack Improvements\nWe're continuing to focus on the reliability and performance of local Next.js development:\n\nReliability: Turbopack passing the entire Next.js development test suite and dogfooding Vercel's applications\nPerformance: Improving Turbopack initial compile times and Fast Refresh times\nMemory Usage: Improving Turbopack memory usage\nWe plan to stabilize next dev --turbo in an upcoming release with it still being opt-in.\n\nReliability\nNext.js with Turbopack now passes 5,600 development tests (94%), 600 more since the last update. You can follow the progress on areweturboyet.com.\n\nWe have continued dogfooding next dev --turbo on all Vercel's Next.js applications, including vercel.com and v0.dev. All engineers working on these applications are using Turbopack daily.\n\nWe've found and fixed a number of issues for very large Next.js applications using Turbopack. For these fixes, we've added new tests to the existing development test suites in Next.js.\n\nPerformance\nFor vercel.com, a large Next.js application, we've seen:\n\nUp to 76.7% faster local server startup\nUp to 96.3% faster code updates with Fast Refresh\nUp to 45.8% faster initial route compile without caching (Turbopack does not have disk caching yet)\nIn v0.dev, we identified an opportunity to optimize the way React Client Components are discovered and bundled in Turbopack - resulting in up to 61.5% faster initial compile time. This performance improvement was also observed in vercel.com.\n\nFuture Improvements\nTurbopack currently has in-memory caching, which improves incremental compilation times for Fast Refresh.\n\nHowever, the cache is currently not preserved when restarting the Next.js development server. The next big step for Turbopack performance is disk caching, which will allow the cache to be preserved when restating the development server.\n\nDeveloper Experience Improvements\nImproved Error Messages and Fast Refresh\nWe know how critical clear error messages are to your local development experience. We've made a number of fixes to improve the quality of stack traces and error messages you see when running next dev.\n\nErrors that previously displayed bundler errors like webpack-internal now properly display the source code of the error and the affected file.\nAfter seeing an error in a client component, and then fixing the error in your editor, the Fast Refresh did not clear the error screen. It required a hard reload. We've fixed a number of these instances. For example, trying to export metadata from a Client Component.\nFor example, this was a previous error message:\n\nAn example of an error from a fetch call in Next.js 14.\nAn example of an error from a fetch call in Next.js 14.\nNext.js 14.1 has improved this to:\n\nErrors from fetch calls during rendering now display the source code of the error and the affected file.\nErrors from fetch calls during rendering now display the source code of the error and the affected file.\nwindow.history.pushState and window.history.replaceState\nThe App Router now allows the usage of the native pushState and replaceState methods to update the browser's history stack without reloading the page.\n\npushState and replaceState calls integrate into the Next.js App Router, allowing you to sync with usePathname and useSearchParams.\n\nThis is helpful when needing to immediately update the URL when saving state like filters, sort order, or other information desired to persist across reloads.\n\n\n'use client';\n \nimport { useSearchParams } from 'next/navigation';\n \nexport default function SortProducts() {\n  const searchParams = useSearchParams();\n \n  function updateSorting(sortOrder: string) {\n    const params = new URLSearchParams(searchParams.toString());\n    params.set('sort', sortOrder);\n    window.history.pushState(null, '', `?${params.toString()}`);\n  }\n \n  return (\n    <>\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\n    </>\n  );\n}\nLearn more about using the native History API with Next.js.\n\nData Cache Logging\nFor improved observability of your cached data in your Next.js application when running next dev, we've made a number of improvements to the logging configuration option.\n\nYou can now display whether there was a cache HIT or SKIP and the full URL requested:\n\nTerminal\n\nGET / 200 in 48ms\n ✓ Compiled /fetch-cache in 117ms\n GET /fetch-cache 200 in 165ms\n  │ GET https://api.vercel.app/products/1 200 in 14ms (cache: HIT)\n ✓ Compiled /fetch-no-store in 150ms\n GET /fetch-no-store 200 in 548ms\n  │ GET https://api.vercel.app/products/1 200 in 345ms (cache: SKIP)\n  │  │  Cache missed reason: (cache: no-store)\nThis can be enabled through next.config.js:\n\nnext.config.js\n\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n};\nnext/image support for <picture> and Art Direction\nThe Next.js Image component now supports more advanced use cases through getImageProps() (stable) which don't require using <Image> directly. This includes:\n\nWorking with background-image or image-set\nWorking with canvas context.drawImage() or new Image()\nWorking with <picture> media queries to implement Art Direction or Light/Dark Mode images\n\nimport { getImageProps } from 'next/image';\n \nexport default function Page() {\n  const common = { alt: 'Hero', width: 800, height: 400 };\n  const {\n    props: { srcSet: dark },\n  } = getImageProps({ ...common, src: '/dark.png' });\n  const {\n    props: { srcSet: light, ...rest },\n  } = getImageProps({ ...common, src: '/light.png' });\n \n  return (\n    <picture>\n      <source media=\"(prefers-color-scheme: dark)\" srcSet={dark} />\n      <source media=\"(prefers-color-scheme: light)\" srcSet={light} />\n      <img {...rest} />\n    </picture>\n  );\n}\nLearn more about getImageProps().\n\nParallel & Intercepted Routes\nIn Next.js 14.1, we've made 20 improvements to Parallel & Intercepted Routes.\n\nFor the past two releases, we've been focused on improving performance and reliability of Next.js. We've now been able to make many improvements to Parallel & Intercepted Routes based on your feedback. Notably, we've added support for catch-all routes and Server Actions.\n\nParallel Routes allow you to simultaneously or conditionally render one or more pages in the same layout. For highly dynamic sections of an app, such as dashboards and feeds on social sites, Parallel Routes can be used to implement complex routing patterns.\nIntercepted Routes allow you to load a route from another part of your application within the current layout. For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the /photo/123 route, masks the URL, and overlays it over /feed.\nLearn more about Parallel & Intercepted Routes or view an example.\n\nOther Improvements\nSince 14.0, we've fixed a number of highly upvoted bugs from the community.\n\nWe've also recently published videos explaining caching and some common mistakes with the App Router that you might find helpful.\n\n[Docs] New documentation on Redirecting\n[Docs] New documentation on Testing\n[Docs] New documentation with a Production Checklist\n[Feature] Add <GoogleAnalytics /> component to next/third-parties (Docs)\n[Improvement] create-next-app is now smaller and faster to install (PR)\n[Improvement] Nested routes throwing errors can still be caught be global-error (PR)\n[Improvement] redirect now respects basePath when used in a server action (PR)\n[Improvement] Fix next/script and beforeInteractive usage with App Router (PR)\n[Improvement] Automatically transpile @aws-sdk and lodash for faster route startup (PR)\n[Improvement] Fix flash of unstyled content with next dev and next/font (PR)\n[Improvement] Propagate notFound errors past a segment's error boundary (PR)\n[Improvement] Fix serving public files from locale domains with Pages Router i18n (PR)\n[Improvement] Error if an invalidate revalidate value is passed (PR)\n[Improvement] Fix path issues on linux machines when build created on windows (PR)\n[Improvement] Fix Fast Refresh / HMR when using a multi-zone app with basePath (PR)\n[Improvement] Improve graceful shutdown from termination signals (PR)\n[Improvement] Modal routes clash when intercepting from different routes (PR)\n[Improvement] Fix intercepting routes when using basePath config (PR)\n[Improvement] Show warning when a missing parallel slot results in 404 (PR)\n[Improvement] Improve intercepted routes when used with catch-all routes (PR)\n[Improvement] Improve intercepted routes when used with revalidatePath (PR)\n[Improvement] Fix usage of @children slots with parallel routes (PR)\n[Improvement] Fix Fix TypeError when using params with parallel routes (PR)\n[Improvement] Fix catch-all route normalization for default parallel routes (PR)\n[Improvement] Fix display of parallel routes in the next build summary (PR)\n[Improvement] Fix for route parameters when using intercepted routes (PR)\n[Improvement] Improve deeply nested parallel/intercepted routes (PR)\n[Improvement] Fix 404 with intercepted routes paired with route groups (PR)\n[Improvement] Fix parallel routes with server actions / revalidating router cache (PR)\n[Improvement] Fix usage of rewrites with an intercepted route (PR)\n[Improvement] Server Actions now work from third-party libraries (PR)\n[Improvement] Next.js can now be used within an ESM package (PR)\n[Improvement] Barrel file optimizations for libraries like Material UI (PR)\n[Improvement] Builds will now fail on incorrect usage of useSearchParams without Suspense (PR)"},{"id":13,"title":"Next.js 14","content":"As we announced at Next.js Conf, Next.js 14 is our most focused release with:\n\nTurbopack: 5,000 tests passing for App & Pages Router\n53% faster local server startup\n94% faster code updates with Fast Refresh\nServer Actions (Stable): Progressively enhanced mutations\nIntegrated with caching & revalidating\nSimple function calls, or works natively with forms\nPartial Prerendering (Preview): Fast initial static response + streaming dynamic content\nNext.js Learn (New): Free course teaching the App Router, authentication, databases, and more.\nUpgrade today or get started with:\n\nTerminal\n\nnpx create-next-app@latest\nNext.js Compiler: Turbocharged\nSince Next.js 13, we've been working to improve local development performance in Next.js in both the Pages and App Router.\n\nPreviously, we were rewriting next dev and other parts of Next.js to support this effort. We have since changed our approach to be more incremental. This means our Rust-based compiler will reach stability soon, as we've refocused on supporting all Next.js features first.\n\n5,000 integration tests for next dev are now passing with Turbopack, our underlying Rust engine. These tests include 7 years of bug fixes and reproductions.\n\nWhile testing on vercel.com, a large Next.js application, we've seen:\n\nUp to 53.3% faster local server startup\nUp to 94.7% faster code updates with Fast Refresh\nThis benchmark is a practical result of performance improvements you should expect with a large application (and large module graph). With 90% of tests for next dev now passing, you should see faster and more reliable performance consistently when using next dev --turbo.\n\nOnce we hit 100% of tests passing, we'll move Turbopack to stable in an upcoming minor release. We'll also continue to support using webpack for custom configurations and ecosystem plugins.\n\nYou can follow the percentage of tests passing at areweturboyet.com.\n\nForms and Mutations\nNext.js 9 introduced API Routes—a way to quickly build backend endpoints alongside your frontend code.\n\nFor example, you would create a new file in the api/ directory:\n\npages/api/submit.ts\n\nimport type { NextApiRequest, NextApiResponse } from 'next';\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  const data = req.body;\n  const id = await createItem(data);\n  res.status(200).json({ id });\n}\nThen, on the client-side, you could use React and an event handler like onSubmit to make a fetch to your API Route.\n\npages/index.tsx\n\nimport { FormEvent } from 'react';\n \nexport default function Page() {\n  async function onSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n \n    const formData = new FormData(event.currentTarget);\n    const response = await fetch('/api/submit', {\n      method: 'POST',\n      body: formData,\n    });\n \n    // Handle response if necessary\n    const data = await response.json();\n    // ...\n  }\n \n  return (\n    <form onSubmit={onSubmit}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\nNow with Next.js 14, we want to simplify the developer experience of authoring data mutations. Further, we want to improve the user experience when the user has a slow network connection, or when submitting a form from a lower-powered device.\n\nServer Actions (Stable)\nWhat if you didn't need to manually create an API Route? Instead, you could define a function that runs securely on the server, called directly from your React components.\n\nThe App Router is built on the React canary channel, which is stable for frameworks to adopt new features. As of v14, Next.js has upgraded to the latest React canary, which includes stable Server Actions.\n\nThe previous example from the Pages Router can be simplified to one file:\n\napp/page.tsx\n\nexport default function Page() {\n  async function create(formData: FormData) {\n    'use server';\n    const id = await createItem(formData);\n  }\n \n  return (\n    <form action={create}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\nServer Actions should feel familiar for any developers who have previously used server-centric frameworks in the past. It's built on web fundamentals like forms and the FormData Web API.\n\nWhile using Server Actions through a form is helpful for progressive enhancement, it is not a requirement. You can also call them directly as a function, without a form. When using TypeScript, this gives you full end-to-end type-safety between the client and server.\n\nMutating data, re-rendering the page, or redirecting can happen in one network roundtrip, ensuring the correct data is displayed on the client, even if the upstream provider is slow. Further, you can compose and reuse different actions, including many different actions in the same route.\n\nCaching, Revalidating, Redirecting, and more\nServer Actions are deeply integrated into the entire App Router model. You can:\n\nRevalidate cached data with revalidatePath() or revalidateTag()\nRedirect to different routes through redirect()\nSet and read cookies through cookies()\nHandle optimistic UI updates with useOptimistic()\nCatch and display errors from the server with useFormState()\nDisplay loading states on the client with useFormStatus()\nLearn more about Forms and Mutations with Server Actions or about the security model and best practices for Server Components and Server Actions.\n\nPartial Prerendering (Preview)\nWe'd like to share a preview of Partial Prerendering — a compiler optimization for dynamic content with a fast initial static response — that we're working on for Next.js.\n\nPartial Prerendering builds on a decade of research and development into server-side rendering (SSR), static-site generation (SSG), and incremental static revalidation (ISR).\n\nMotivation\nWe've heard your feedback. There's currently too many runtimes, configuration options, and rendering methods to have to consider. You want the speed and reliability of static, while also supporting fully dynamic, personalized responses.\n\nHaving great performance globally and personalization shouldn't come at the cost of complexity.\n\nOur challenge was to create a better developer experience, simplifying the existing model without introducing new APIs for developers to learn. While partial caching of server-side content has existed, these approaches still need to meet the developer experience and composability goals we aim for.\n\nPartial Prerendering requires no new APIs to learn.\n\nBuilt on React Suspense\nPartial Prerendering is defined by your Suspense boundaries. Here's how it works. Consider the following ecommerce page:\n\napp/page.tsx\n\nexport default function Page() {\n  return (\n    <main>\n      <header>\n        <h1>My Store</h1>\n        <Suspense fallback={<CartSkeleton />}>\n          <ShoppingCart />\n        </Suspense>\n      </header>\n      <Banner />\n      <Suspense fallback={<ProductListSkeleton />}>\n        <Recommendations />\n      </Suspense>\n      <NewProducts />\n    </main>\n  );\n}\nWith Partial Prerendering enabled, this page generates a static shell based on your <Suspense /> boundaries. The fallback from React Suspense is prerendered.\n\nSuspense fallbacks in the shell are then replaced with dynamic components, like reading cookies to determine the cart, or showing a banner based on the user.\n\nWhen a request is made, the static HTML shell is immediately served:\n\n\n<main>\n  <header>\n    <h1>My Store</h1>\n    <div class=\"cart-skeleton\">\n      <!-- Hole -->\n    </div>\n  </header>\n  <div class=\"banner\" />\n  <div class=\"product-list-skeleton\">\n    <!-- Hole -->\n  </div>\n  <section class=\"new-products\" />\n</main>\nSince <ShoppingCart /> reads from cookies to look at the user session, this component is then streamed in as part of the same HTTP request as the static shell. There are no extra network roundtrips needed.\n\napp/cart.tsx\n\nimport { cookies } from 'next/headers'\n \nexport default function ShoppingCart() {\n  const cookieStore = cookies()\n  const session = cookieStore.get('session')\n  return ...\n}\nTo have the most granular static shell, this may require adding additional Suspense boundaries. However, if you're already using loading.js today, this is an implicit Suspense boundary, so no changes would be required to generate the static shell.\n\nComing soon\nPartial prerendering is under active development. We'll be sharing more updates in an upcoming minor release.\n\nMetadata Improvements\nBefore your page content can be streamed from the server, there's important metadata about the viewport, color scheme, and theme that need to be sent to the browser first.\n\nEnsuring these meta tags are sent with the initial page content helps a smooth user experience, preventing the page from flickering by changing the theme color, or shifting layout due to viewport changes.\n\nIn Next.js 14, we've decoupled blocking and non-blocking metadata. Only a small subset of metadata options are blocking, and we want to ensure non-blocking metadata will not prevent a partially prerendered page from serving the static shell.\n\nThe following metadata options are now deprecated and will be removed from metadata in a future major version:\n\nviewport: Sets the initial zoom and other properties of the viewport\ncolorScheme: Sets the support modes (light/dark) for the viewport\nthemeColor: Sets the color the chrome around the viewport should render with\nStarting with Next.js 14, there are new options viewport and generateViewport to replace these options. All other metadata options remain the same.\n\nYou can start adopting these new APIs today. The existing metadata options will continue to work.\n\nNext.js Learn Course\nToday we're releasing a brand new, free course on Next.js Learn. This course teaches:\n\nThe Next.js App Router\nStyling and Tailwind CSS\nOptimizing Fonts and Images\nCreating Layouts and Pages\nNavigating Between Pages\nSetting Up Your Postgres Database\nFetching Data with Server Components\nStatic and Dynamic Rendering\nStreaming\nPartial Prerendering (Optional)\nAdding Search and Pagination\nMutating Data\nHandling Errors\nImproving Accessibility\nAdding Authentication\nAdding Metadata"},{"id":14,"title":"How to Think About Security in Next.js","content":"React Server Components (RSC) in App Router is a novel paradigm that eliminates much of the redundancy and potential risks linked with conventional methods. Given the newness, developers and subsequently security teams may find it challenging to align their existing security protocols with this model.\n\nThis document is meant to highlight a few areas to look out for, what protections are built-in, and include a guide for auditing applications. We focus especially on the risks of accidental data exposure.\n\nChoosing Your Data Handling Model\nReact Server Components blur the line between server and client. Data handling is paramount in understanding where information is processed and subsequently made available.\n\nThe first thing we need to do is pick what data handling approach is appropriate for our project.\n\nHTTP APIs (recommended for existing large projects / orgs)\nData Access Layer (recommended for new projects)\nComponent Level Data Access (recommended for prototyping and learning)\nWe recommend that you stick to one approach and don't mix and match too much. This makes it clear for both developers working in your code base and security auditors for what to expect. Exceptions pop out as suspicious.\n\nHTTP APIs\nIf you're adopting Server Components in an existing project, the recommended approach is to handle Server Components at runtime as unsafe/untrusted by default like SSR or within the client. So there is no assumption of an internal network or zones of trust and engineers can apply the concept of Zero Trust. Instead, you only call custom API endpoints such as REST or GraphQL using fetch() from Server Components just like if it was executing on the client. Passing along any cookies.\n\nIf you had existing getStaticProps/getServerSideProps connecting to a database, you might want to consolidate the model and move these to API end points as well so you have one way to do things.\n\nLook out for any access control that assumes fetches from the internal network are safe.\n\nThis approach lets you keep existing organizational structures where existing backend teams, specialized in security can apply existing security practices. If those teams use languages other than JavaScript, that works well in this approach.\n\nIt still takes advantage of many of the benefits of Server Components by sending less code to the client and inherent data waterfalls can execute with low latency.\n\nData Access Layer\nOur recommended approach for new projects is to create a separate Data Access Layer inside your JavaScript codebase and consolidate all data access in there. This approach ensures consistent data access and reducing the chance of authorization bugs occurring. It's also easier to maintain given you're consolidating into a single library. Possibly providing better team cohesion with a single programming language. You also get to take advantage of better performance with lower runtime overhead, the ability to share an in-memory cache across different parts of a request.\n\nYou build an internal JavaScript library that provides custom data access checks before giving it to the caller. Similar to HTTP endpoints but in the same memory model. Every API should accept the current user and check if the user can see this data before returning it. The principle is that a Server Component function body should only see data that the current user issuing the request is authorized to have access to.\n\nFrom this point, normal security practices for implementing APIs take over.\n\ndata/auth.tsx\n\nimport { cache } from 'react';\nimport { cookies } from 'next/headers';\n \n// Cached helper methods makes it easy to get the same value in many places\n// without manually passing it around. This discourages passing it from Server\n// Component to Server Component which minimizes risk of passing it to a Client\n// Component.\nexport const getCurrentUser = cache(async () => {\n  const token = cookies().get('AUTH_TOKEN');\n  const decodedToken = await decryptAndValidate(token);\n  // Don't include secret tokens or private information as public fields.\n  // Use classes to avoid accidentally passing the whole object to the client.\n  return new User(decodedToken.id);\n});\ndata/user-dto.tsx\n\nimport 'server-only';\nimport { getCurrentUser } from './auth';\n \nfunction canSeeUsername(viewer: User) {\n  // Public info for now, but can change\n  return true;\n}\n \nfunction canSeePhoneNumber(viewer: User, team: string) {\n  // Privacy rules\n  return viewer.isAdmin || team === viewer.team;\n}\n \nexport async function getProfileDTO(slug: string) {\n  // Don't pass values, read back cached values, also solves context and easier to make it lazy\n \n  // use a database API that supports safe templating of queries\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`;\n  const userData = rows[0];\n \n  const currentUser = await getCurrentUser();\n \n  // only return the data relevant for this query and not everything\n  // <https://www.w3.org/2001/tag/doc/APIMinimization>\n  return {\n    username: canSeeUsername(currentUser) ? userData.username : null,\n    phonenumber: canSeePhoneNumber(currentUser, userData.team)\n      ? userData.phonenumber\n      : null,\n  };\n}\nThese methods should expose objects that are safe to be transferred to the client as is. We like to call these Data Transfer Objects (DTO) to clarify that they're ready to be consumed by the client.\n\nThey might only get consumed by Server Components in practice. This creates a layering where security audits can focus primarily on the Data Access Layer while the UI can rapidly iterate. Smaller surface area and less code to cover makes it easier to catch security issues.\n\n\nimport {getProfile} from '../../data/user'\nexport async function Page({ params: { slug } }) {\n  // This page can now safely pass around this profile knowing\n  // that it shouldn't contain anything sensitive.\n  const profile = await getProfile(slug);\n  ...\n}\nSecret keys can be stored in environment variables but only the data access layer should access process.env in this approach.\n\nComponent Level Data Access\nAnother approach is to just put your database queries directly in your Server Components. This approach is only appropriate for rapid iteration and prototyping. E.g. for a small product with a small team where everyone is aware of the risks and how to watch for them.\n\nIn this approach you'll want to audit your \"use client\" files carefully. While auditing and reviewing PRs, look at all the exported functions and if the type signature accepts overly broad objects like User, or contains props like token or creditCard. Even privacy sensitive fields like phoneNumber need extra scrutiny. A Client Component should not accept more data than the minimal data it needs to perform its job.\n\n\nimport Profile from './components/profile.tsx';\n \nexport async function Page({ params: { slug } }) {\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`;\n  const userData = rows[0];\n  // EXPOSED: This exposes all the fields in userData to the client because\n  // we are passing the data from the Server Component to the Client.\n  // This is similar to returning `userData` in `getServerSideProps`\n  return <Profile user={userData} />;\n}\n\n'use client';\n// BAD: This is a bad props interface because it accepts way more data than the\n// Client Component needs and it encourages server components to pass all that\n// data down. A better solution would be to accept a limited object with just\n// the fields necessary for rendering the profile.\nexport default async function Profile({ user }: { user: User }) {\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      ...\n    </div>\n  );\n}\nAlways use parameterized queries, or a db library that does it for you, to avoid SQL injection attacks.\n\nServer Only\nCode that should only ever execute on the server can be marked with:\n\n\nimport 'server-only';\nThis will cause the build to error if a Client Component tries to import this module. This can be used to ensure that proprietary/sensitive code or internal business logic doesn't accidentally leak to the client.\n\nThe primary way to transfer data is using the React Server Components protocol which happens automatically when passing props to the Client Components. This serialization supports a superset of JSON. Transferring custom classes is not supported and will result in an error.\n\nTherefore, a nice trick to avoid too large objects being accidentally exposed to the client is to use class for your data access records.\n\nIn the upcoming Next.js 14 release, you can also try out the experimental React Taint APIs by enable the taint flag in next.config.js.\n\nnext.config.js\n\nmodule.exports = {\n  experimental: {\n    taint: true,\n  },\n};\nThis lets you mark an object that should not be allowed to be passed to the client as is.\n\napp/data.ts\n\nimport { experimental_taintObjectReference } from 'react';\n \nexport async function getUserData(id) {\n  const data = ...;\n  experimental_taintObjectReference(\n    'Do not pass user data to the client',\n    data\n  );\n  return data;\n}\napp/page.tsx\n\nimport { getUserData } from './data';\n \nexport async function Page({ searchParams }) {\n  const userData = getUserData(searchParams.id);\n  return <ClientComponent user={userData} />; // error\n}\nThis does not protect against extracting data fields out of this object and passing them along:\n\napp/page.tsx\n\nexport async function Page({ searchParams }) {\n  const { name, phone } = getUserData(searchParams.id);\n  // Intentionally exposing personal data\n  return <ClientComponent name={name} phoneNumber={phone} />;\n}\nFor unique strings such as tokens, the raw value can be blocked as well using taintUniqueValue.\n\napp/data.ts\n\nimport { experimental_taintObjectReference, experimental_taintUniqueValue } from 'react';\n \nexport async function getUserData(id) {\n  const data = ...;\n  experimental_taintObjectReference(\n    'Do not pass user data to the client',\n    data\n  );\n  experimental_taintUniqueValue(\n    'Do not pass tokens to the client',\n    data,\n    data.token\n  );\n  return data;\n}\nHowever, even this doesn't block derived values.\n\nIt's better to avoid data getting into the Server Components in the first place - using a Data Access Layer. Taint checking provides an additional layer of protection against mistakes by specifying the value, please be mindful that functions and classes are already blocked from being passed to Client Components. More layers the minimize risk of something slipping through.\n\nBy default, environment variables are only available on the Server. By convention, Next.js also exposes any environment variable prefixed with NEXT_PUBLIC_ to the client. This lets you expose certain explicit configuration that should be available to the client.\n\nSSR vs RSC\nFor initial load Next.js will run both the Server Components and the Client Components on the server to produce HTML.\n\nServer Components (RSC) execute in a separate module system from the Client Components to avoid accidentally exposing information between the two modules.\n\nClient Components that render through Server-side Rendering (SSR) should be considered as the same security policy as the browser client. It should not gain access to any privileged data or private APIs. It's highly discouraged to use hacks to try to circumvent this protection (such as stashing data on the global object). The principle is that this code should be able to execute the same on the server as the client. In alignment with secure by default practices, Next.js will fail the build if server-only modules are imported from a Client Component."},{"id":15,"title":"Next.js 13.5","content":"Next.js 13.5 improves local dev performance and reliability with:\n\n22% faster local server startup: Iterate faster with the App & Pages Router\n29% faster HMR (Fast Refresh): For faster iterations when saving changes\n40% less memory usage: Measured when running next start\nOptimized Package Imports: Faster updates when using popular icon and component libraries\nnext/image Improvements: <picture>, art direction, and dark mode support\nAnd over 438 bugs patched!\nUpgrade today and register for Next.js Conf on Oct 26:\n\n\nnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\nImproving startup and Fast Refresh time\nWe're excited to see the continued adoption of the App Router, now growing 80% MoM when looking at the top 10 million origins crawled by the HTTP Archive.\n\n2023 CRuX Dataset for Top 1 Million Mobile Sites on the Web\nSince Next.js 13.4, our focus has been on improving performance and reliability for App Router applications. Comparing 13.4 to 13.5, we've seen the following improvements on a new application:\n\n22% faster local server startup\n29% faster HMR (Fast Refresh)\n40% less memory usage\nWe were able to achieve this performance increase through optimizations like:\n\nDoing less work by caching or minimizing slow operations\nOptimizing expensive file system operations\nBetter incremental tree traversal during compilation\nMoving unnecessary blocking synchronous calls to be lazy\nAutomatically configuring large icon libraries\nNext.js user Lattice reported between 87-92% faster compilation in their testing.\n\nWhile we continue to iterate and improve our current bundler performance, we're also working on Turbopack (Beta) in parallel to further increase performance. With 13.5, next dev --turbo now supports more features.\n\nOptimized Package Imports\nWe've made an exciting breakthrough to optimize package imports, improving both local dev performance and production cold starts, when using large icon or component libraries or other dependencies that re-export hundreds or thousands of modules.\n\nPreviously, we added support for modularizeImports, enabling you to configure how imports should resolve when using these libraries. In 13.5, we have superseeded this option with optimizePackageImports, which doesn't require you to specify the mapping of imports, but instead will automatically optimize imports for you.\n\nLibraries like @mui/icons-material, @mui/material, date-fns, lodash, lodash-es, ramda, react-bootstrap, @headlessui/react ,@heroicons/react , and lucide-react are now automatically optimized, only loading the modules you are actually using, while still giving you the convenience of writing import statements with many named exports.\n\nView the PR or learn more about optimizePackageImports in our documentation.\n\nnext/image Improvements\nBased on community feedback, we've added a new experimental function unstable_getImgProps() to support advanced use cases without using the <Image> component directly, including:\n\nWorking with background-image or image-set\nWorking with canvas context.drawImage() or new Image()\nWorking with <picture> media queries to implement Art Direction or Light/Dark Mode images\n\nimport { unstable_getImgProps as getImgProps } from 'next/image';\n \nexport default function Page() {\n  const common = { alt: 'Hero', width: 800, height: 400 };\n  const {\n    props: { srcSet: dark },\n  } = getImgProps({ ...common, src: '/dark.png' });\n  const {\n    props: { srcSet: light, ...rest },\n  } = getImgProps({ ...common, src: '/light.png' });\n \n  return (\n    <picture>\n      <source media=\"(prefers-color-scheme: dark)\" srcSet={dark} />\n      <source media=\"(prefers-color-scheme: light)\" srcSet={light} />\n      <img {...rest} />\n    </picture>\n  );\n}\nAdditionally, the placeholder prop now supports providing arbitrary data:image/ for placeholder images that shouldn't be blurred (demo).\n\nLearn more about next/image in our documentation.\n\nOther Improvements\nSince 13.4.0, we've fixed over 438 bugs and made various improvements including:\n\n[Docs] New documentation on Forms and Mutations\n[Docs] New documentation on Server and Client Components\n[Docs] New documentation on Content Security Policy and Nonces\n[Docs] New documentation on Caching and Revalidating\n[Feature] useParams and useSearchParams from next/navigation now work in the Pages Router for incremental adoption\n[Feature] Support for scroll: false on router.push / router.replace\n[Feature] Support for scroll={false} on next/link\n[Feature] HTTPS support for development: next dev --experimental-https\n[Feature] Added support for cookies().has() (Docs)\n[Feature] Added support for IPv6 hostnames\n[Feature] Added support for Yarn PnP with the App Router\n[Feature] Added support for redirect() in Server Actions\n[Feature] Added support for using Bun with creating projects: bunx create-next-app (Docs)\n[Feature] Draft Mode support for use inside Middleware and the Edge Runtime\n[Feature] cookies() and headers() are now supported inside Middleware\n[Feature] Metadata API now supports summary_large_image in Twitter cards\n[Feature] RedirectType is now exported from next/navigation\n[Feature] Added experimental test mode for Playwright (Docs)\n[Improvement] Refactored next start to handle 1062% more requests/second\n[Improvement] Optimized Next.js internals to improve cold starts (up to 40% faster, tested on Vercel)\n[Improvement] Better Jest support for the App Router (PR)\n[Improvement] Redesigned next dev output (PR)\n[Improvement] Server Actions now work with fully static routes (including revalidating data with ISR)\n[Improvement] Server Actions no longer block navigation between routes\n[Improvement] Server Actions can no longer trigger multiple concurrent actions\n[Improvement] Server Actions calling redirect() now push into the history stack instead of replacing the current entry to ensure the back button works\n[Improvement] Server Actions add no-cache, no-store cache-control header to prevent browser caching\n[Improvement] Fixed a bug where Server Actions could be called twice after navigating\n[Improvement] Improved support for Emotion CSS with Server Components\n[Improvement] Support for scroll-behavior: smooth for hash url changes\n[Improvement] Added polyfill for Array.prototype.at in all browsers\n[Improvement] Fixed race condition in next dev cache when handling multiple parallel requests\n[Improvement] fetch output in console now shows requests that skipped cache with cache: SKIP\n[Improvement] usePathname now properly strips basePath\n[Improvement] next/image now properly preloads images in App Router\n[Improvement] not-found no longer renders the root layout twice\n[Improvement] NextRequest can now be cloned (i.e new NextRequest(request))\n[Improvement] app/children/page.tsx now properly works for literal /children routes\n[Improvement] Content Security Policy now supports nonce for preinitialized scripts\n[Improvement] Using redirect from next/navigation now supports basePath\n[Improvement] Fixed process.env not being available during rendering in output: 'standalone' mode\n[Improvement] Improved error message when using a Static Export with unsupported features\n[Improvement] Improved recursive readdir implementation (~3x faster)\n[Improvement] Fixed fallback: false with dynamic route segments previously causing hanging requests\n[Improvement] Fixed error where signal was passed to revalidate requests, causing them to fail when the request was already aborted\n[Improvement] Removed fetch polling on 404 page in favor of websocket events, preventing unnecessary reloads when running next dev\n[Improvement] performance.measure no longer can cause a hydration mismatch\n[Improvement] Fixed cases where an unexpected full reload could happen editing pages/_app\n[Improvement] ImageResponse now extends Response for improved type checking (PR)\n[Improvement] pages is no longer shown when there is no pages output in next build\n[Improvement] Fixed skipTrailingSlashRedirect being ignored in <Link>\n[Improvement] Fixed duplicated dynamic metadata routes in dev mode"},{"id":16,"title":"Next.js App Router Update","content":"The App Router represents a new foundation for the future of Next.js, but we recognize there are opportunities to make the experience better. We'd like to give an update on what our current priorities are.\n\nFor the upcoming releases of Next.js, we are focusing on the following areas:\n\nImproving Performance\nImproving Stability\nImproving Developer Education\nThe App Router\nFirst, it's helpful to provide some context on how the App Router has been designed.\n\nGrowing Beyond the Pages Router by Aligning with React\nAs we saw increased adoption and larger scale applications being built with Next.js, we received feedback from the community and identified areas where we started to reach the limits of the Pages Router.\n\nMost notably, the Next.js Pages Router was not designed for streaming, a cornerstone primitive in modern React, that helps us address the limitations we were facing and realize our long-term vision for Next.js.\n\nMaking streaming-friendly framework APIs for data fetching, asset loading, and page metadata, as well as taking advantage of React's newer primitives required large changes to the core architecture of Next.js.\n\nWe took the opportunity to build on top of the latest React concurrent features, like Server Components, Suspense, and more, which have been designed for streaming architectures.\n\nIncremental Adoption is Non-Negotiable\nWe didn't want our community to have to rebuild their entire applications from the ground up to update to the latest version of Next.js. We believe incremental adoption is the best strategy for evolving applications over time.\n\nPer-route incremental migration: Without a major rewrite of your application, you can move a single route of your application over the App Router and start to take advantage of new features at your own pace. See our incremental adoption guide or watch a tutorial.\nEasily rollback: If you are not satisifed with the performance or developer experience of the App Router, you can easily rollback to the Pages Router for that specific route.\nWe are exploring further opportunities to make incremental adoption even easier.\n\nRoad to Stability\nWe began building the Next.js App Router over a year ago and have been steadily releasing new features and improvements since then.\n\nInitial Announcement: In May of that year, we released an RFC to outline our plans for making routing and layouts more flexible.\nEarly Beta: In Next.js 13, we released the first version of the App Router, allowing the community to try it out and provide early feedback.\nStable API: Responding to feedback, we focused our efforts on finalizing the core API. In 13.4, we marked the core API of the App Router as stable and ready for wider adoption.\nOur Current Focus\nMarking stability signaled to the community that the core API was settled and would not go through major breaking changes that would require rewrites.\n\nSince then, we've received lots of valuable feedback and increased adoption has inevitably revealed bugs and opportunities for further improvement.\n\nWe want you to know that we are not yet satisfied with the experience of using the App Router and it is our top priority moving forward. So, let's talk about the work we're doing to make this experience better.\n\nImproving Performance\nOver the coming months, we're focused on three aspects of performance: local iteration speed, production build times, and serverless performance.\n\nLocal development performance\nAs Next.js has matured, and the size of applications built with it have grown, we've slowly and incrementally been replacing pieces of its underlying architecture with faster, more scalable tools.\n\nMigration Progress: We started with replacing Babel (compilation) and Terser (minification) with SWC. This has helped improve local iteration speeds and production build times.\n\nLong-term Investment: Keeping great Fast Refresh performance regardless of an applications size means making Next.js operate as incremental as possible during local development, by only bundling and compiling code as needed.\n\nThis is why we're currently working on replacing webpack (bundling) with Turbopack, which is built on a low-level incremental computation engine that enables caching down to the level of individual functions.\n\nNext.js applications that move to Turbopack will see sustained improvements in Fast Refresh speed even as they grow in size.\n\nIn the past few months, the Turbo team has been focused on improving Turbopack performance and support for all Next.js features and App Router APIs.\n\nTurbopack is currently available in beta (next dev --turbo).\n\nImproving Today's Architecture: In addition to investing in the future, we are continuing to make performance improvements to our existing webpack architecture.\n\nFor certain Next.js applications, especially those refreshing thousands of modules, we have seen reports of flakiness with local development and Fast Refresh. We're working to improve performance and reliability here. For example, we recently added in pre-configured settings (modularizeImports) to handle large icon libraries that might accidentally force thousands of modules to reload on every request.\n\nBuild-time performance\nWe are also working on production builds with Turbopack (next build --turbo) and have started to land the first pieces of this work. Expect more updates on this in the coming releases.\n\nProduction performance\nFinally, on Vercel, we're working to optimize the performance and memory usage of Vercel Functions defined through Next.js application code, ensuring minimal cold starts while retaining the benefits of a scalable serverless architecture. This work has resulted in new tracing capabilities (experimental) in Next.js and early explorations into server-side developer tools.\n\nImproving Stability\nThe Pages Router has been around for six years now. The release of the App Router meant the introduction of new APIs which are still young, with just six months of usage. We've come a long way in a short amount of time, but there are still opportunities to improve as we learn more from our community and how they're using it.\n\nWe appreciate the community's willingness to eagerly adopt the App Router and provide feedback. There's been a number of bug reports we're investigating and we're thankful for the minimal reproductions you have created to help isolate issues and verify fixes.\n\nSince 13.4, we've already patched a number of high impact bugs around stability that are available in the latest patch release (13.4.7). We will be continuing to focus on performance and stability with high intensity.\n\nImproving Developer Education\nWhile we believe the new features of the App Router and modern React are powerful, they also require additional education and documentation to help teach these new concepts.\n\nNext.js features\nWe've been working over the past year to re-write the Next.js documentation from scratch. This work is now live on nextjs.org/docs. We'd like to highlight some important pieces:\n\nPages and App toggles: You can switch between learning the Pages Router or App Router documentation using the button on the left side of the documentation. Further, you can filter search results based on your router choice.\nImproved content and information architecture: Almost every single page of the App Router documentation has been refreshed, including more clear structure and cohesiveness between pages, and hundreds of new illustrations to visually explain how Next.js works.\nMore to come: We have more work to do here. The Developer Experience team at Vercel is working hard to provide additional learning resources (including an updated course on /learn teaching the App Router) and real world codebase examples (including a rewrite of Next.js Commerce).\nWe'll be releasing new content in the documentation, on Twitter, YouTube, and more.\n\nNew React features\nWe've also heard your feedback about the education around new React features that are available in the Next.js App Router.\n\nServer Components: It's important to note that features like Server Components and conventions like the \"use client\" directive are not Next.js specific, but a larger part of the React ecosystem.\n\nOur team, our partners at Meta, and other independent contributors are working to provide more education around these topics. It's early days for these concepts, but we're confident in the React ecosystem and continued education.\n\nClient Components: With the recent conversation around Server Components, it's important to note the client components are not a de-optimization. The client is a valid part of the React model and is not going away.\n\nYou can think of client components as the existing Next.js ecosystem today, where your favorite libraries and tools continue to work. For example, a common question we've seen is whether \"use client\" needs to be added to every single file to make it a client component. This is not necessary, but we understand these concepts are new and will take time to learn. You only need to mark the top level boundary where you code moves between the server to the client. This architecture allows you to interweave server and client components together.\n\nGrowing third-party ecosystem: In addition to education, the ecosystem around React's newer features is still growing. For example, Panda CSS, a CSS-in-JS library from the makers of Chakra UI, just announced support for React Server Components.\n\nServer Actions (Alpha): Server Actions enable server-side data mutations, reduced client-side JavaScript, and progressively enhanced forms. We do not recommend using Server Actions in production yet. We appreciate early feedback from alpha testers helping us shape the future of this feature."}]